---
description: 'VS Code Copilot カスタムエージェント作成のベストプラクティス'
applyTo: '**/.github/agents/**/*.agent.md, **/.github/chatmodes/**/*.chatmode.md'
---

# カスタムエージェント作成ガイドライン

特定の開発タスクに特化したAI設定を提供するカスタムエージェントを作成する際のベストプラクティスです。

## YAMLフロントマター設計

### 必須プロパティ

#### description（必須）

エージェントの目的と機能を明確に記述してください。

```yaml
# 良い例
description: テストカバレッジと品質を向上させ、本番コードを変更しないテスト専門家

# 悪い例
description: テスト用エージェント
```

- 具体的で簡潔な説明を記述する
- チャット入力フィールドのプレースホルダーとして表示される
- 50〜100文字程度が目安

### オプションプロパティ設計

#### name

- 目的が明確でわかりやすい名前を付ける
- ケバブケース（`test-specialist`）を使用
- 省略時はファイル名が使用される

#### tools - 最小権限の原則を適用

**必要最小限のツールのみを許可してください。**

| タスクタイプ | 推奨ツール | 理由 |
|----------|----------|------|
| 計画・分析 | `["read", "search", "fetch"]` | 読み取り専用で、誤った変更を防止 |
| 実装 | `["read", "edit", "search", "execute"]` | コード変更と実行が必要 |
| レビュー | `["read", "search"]` | コード確認のみ、変更は不要 |
| テスト作成 | `["read", "edit", "search", "execute"]` | テストファイルの作成と実行 |
| ドキュメント作成 | `["read", "edit", "search"]` | ドキュメントファイルの作成と更新 |

```yaml
# 良い例 - 読み取り専用タスク
tools: ["read", "search", "fetch"]

# 良い例 - 実装タスク
tools: ["read", "edit", "search", "execute"]

# 避けるべき - すべてのツールを許可
tools: ["*"]
```

**利用可能なツールエイリアス**:

- `read` - ファイル内容の読み取り
- `edit` - ファイルの編集（str_replace等）
- `search` - ファイルやテキストの検索（grep, glob）
- `execute` - シェルコマンドの実行
- `agent` - 他のカスタムエージェントの呼び出し
- `web` - URLからのコンテンツ取得、Web検索
- `todo` - 構造化タスクリストの管理

**MCPサーバーツールの指定**:

```yaml
# 特定のMCPツール
tools: ["read", "edit", "github/list-repos"]

# MCPサーバーのすべてのツール
tools: ["playwright/*", "github/*"]
```

#### model

タスクの複雑さに応じてモデルを選択してください。

```yaml
# 複雑な分析・実装タスク
model: Claude Sonnet 4

# シンプルなフォーマット変更・軽量タスク
model: Claude Haiku
```

#### target

実行環境を制限する場合に指定します。

```yaml
# VS Codeのみで利用
target: vscode

# GitHub Copilotのみで利用
target: github-copilot
```

#### infer

自動エージェント選択を無効にする場合に使用します。

```yaml
# 手動選択が必要な場合
infer: false

# デフォルトは true（自動選択）
```

#### handoffs - エージェント間の遷移を設計

順次ワークフローを設計してください。

```yaml
handoffs:
  - label: 計画を確認
    agent: reviewer
    prompt: この実装計画をレビューし、改善提案をしてください。
    send: false
  - label: 実装を開始
    agent: implementation
    prompt: 計画に基づいてコードを実装してください。
    send: false
```

**send プロパティの使い分け**:

- `send: false` - ユーザーがプロンプトを確認・編集してから送信（推奨）
- `send: true` - プロンプトを自動送信（確実な次ステップの場合のみ）

#### argument-hint

チャット入力フィールドに表示されるヒントテキストを提供します。

```yaml
argument-hint: "機能名または説明を入力してください"
```

## エージェント本体（プロンプト）の設計

### 明確な役割定義

エージェントの役割、責任、実行方法を明確に記述してください。

```markdown
# 計画策定の専門家

あなたは技術計画の専門家で、包括的な実装計画の作成に特化しています。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャドキュメントを作成する
- 明確なステップ、依存関係、タイムラインを含む実装計画を生成する
- API設計、データモデル、システム間の相互作用を文書化する

## 実行ガイドライン

- 明確な見出し、タスク分解、受け入れ基準で計画を構造化する
- テスト、デプロイメント、潜在的なリスクへの配慮を含める
- コードの実装ではなく、徹底的な文書化に焦点を当てる
```

### タスク固有の指示

具体的で実行可能な手順を提供してください。

```markdown
## コードレビュープロセス

1. **セキュリティレビュー**: 一般的な脆弱性（SQLインジェクション、XSS、認証の問題）をチェック
2. **パフォーマンス分析**: 非効率なアルゴリズム、不要なループ、最適化の機会を特定
3. **コード品質**: コーディング標準への準拠、命名規則、コメントの明確さを確認
4. **テストカバレッジ**: 既存のテストが変更をカバーしているか評価
5. **ドキュメント**: 変更がドキュメントされ、理解しやすいことを確認
```

### 制約と境界の明示

エージェントが何をすべきで、何をすべきでないかを明確にしてください。

```markdown
## 制約事項

- テストファイルのみに焦点を当て、特に要求されない限り本番コードを変更しない
- すべてのテストは独立性、決定性、十分な文書化を確保する
- 言語とフレームワークに適したテストパターンを使用する
```

### Markdownリンクによる参照

他のファイルやカスタムインストラクションを参照して、重複を避けてください。

```text
詳細なコーディング標準については、プロジェクトのコーディング規約を参照してください。
```

### ツール参照の記法

エージェント本文でツールを参照する場合は、`#tool:<tool-name>` 構文を使用します。

```text
プロジェクト構造を理解するために、#tool:search を使用してコードベースを探索してください。
```

## セキュリティベストプラクティス

### シークレット管理

**絶対に平文でシークレットをファイルに含めないでください。**

```yaml
# 良い例 - シークレット参照
env:
  API_KEY: ${{ secrets.API_KEY }}

# 悪い例 - 平文でシークレットを記述
env:
  API_KEY: "my-secret-key"
```

組織/エンタープライズレベルのエージェントでシークレットを参照する場合:

- リポジトリの "copilot" 環境に設定する
- `${{ secrets.SECRET_NAME }}` 構文を使用する

### ツールアクセス制限

- 必要最小限のツールのみを許可する
- `execute` ツールの使用には特に注意する

```yaml
# セキュリティレビューエージェント
tools: ["read", "search"]  # executeは不要
```

### 環境の分離

`target` プロパティを使用して実行環境を制限してください。

```yaml
target: vscode  # VS Codeのみで利用
```

## 一般的なアンチパターンと解決策

### ❌ アンチパターン1: ツール権限が広すぎる

```yaml
# 避けるべき
tools: ["*"]
```

**解決策**: タスクに必要な最小限のツールのみを許可

```yaml
# 推奨
tools: ["read", "search"]  # 分析タスク
```

### ❌ アンチパターン2: 不明確な指示

```markdown
# 避けるべき
コードを改善してください。
```

**解決策**: 具体的で実行可能な指示

```markdown
# 推奨
## 改善ガイドライン

1. 冗長なコードを削除する
2. 複雑な関数をより小さな関数に分割する
3. 適切なエラーハンドリングを追加する
4. パフォーマンス上のボトルネックを特定する
```

### ❌ アンチパターン3: ハンドオフの欠如

エージェント間の遷移が手動で煩雑になります。

**解決策**: 適切なハンドオフを定義

```yaml
handoffs:
  - label: 次のステップへ
    agent: next-agent
    prompt: 前のステップで生成された内容を確認し、次の作業を進めてください。
    send: false
```

### ❌ アンチパターン4: すべてのタスクに同じモデルを使用

**解決策**: タスクの複雑さに応じてモデルを選択

```yaml
# 複雑な分析タスク
model: Claude Sonnet 4

# シンプルなフォーマット変更
model: Claude Haiku
```

## パフォーマンス最適化

### ツールの効率的な選択

- 不要なツールを含めない（処理が遅くなる可能性）
- タスクに特化したツールセットを定義

### プロンプトサイズの管理

- プロンプトは最大30,000文字
- 大きなファイルは参照リンクを使用

```text
詳細は別ドキュメントを参照してください。
```

### モデル選択の最適化

- 軽量タスクには軽量モデル（Haiku）を使用
- 複雑なタスクのみ高性能モデル（Sonnet, Opus）を使用

## 保守性とスケーラビリティ

### モジュール化

再利用可能な指示は別ファイルに分離し、Markdownリンクで参照してください。

```text
共通のコーディング標準については、プロジェクトのインストラクションファイルを参照してください。
```

### バージョン管理

- エージェントファイルはGitで管理する
- 変更履歴を追跡する
- ブランチやタグで異なるバージョンを管理する

### 命名規則の統一

- エージェント名は目的を明確に反映
- ファイル名はケバブケース（例: `test-specialist.agent.md`）

### ドキュメント化

- 各エージェントの目的と使用方法を明確に記述
- チーム内で共有するガイドラインを作成

## テストと検証

### エージェントのテスト

- 作成したエージェントを実際のタスクでテストする
- 想定外の動作を確認し、指示を改善する

### ハンドオフのテスト

- エージェント間の遷移が適切に機能するか確認する
- プロンプトの内容が次のエージェントに適切に渡されるか検証する

### ツール利用の検証

- 指定したツールが適切に使用されているか確認する
- 不要なツールが使用されていないか確認する

## カスタムインストラクションとの連携

### 重複を避ける

- 共通のルールはカスタムインストラクションに記述し、エージェントから参照する
- エージェント固有の指示のみをエージェントファイルに含める

### 階層的な組織化

プロジェクト全体 → ファイルタイプ → エージェント固有の順で指示を構造化してください。

エージェントファイルの例:

```yaml
---
name: code-reviewer
description: コーディング標準に従ってコードをレビュー
tools: ["read", "search"]
---
```

```text
# コードレビュー専門家

このエージェントは、プロジェクトのコーディング標準を厳密に適用します。

詳細なコーディング標準については、プロジェクトのコーディング規約を参照してください。
```

## 組織レベルのベストプラクティス

### 組織/エンタープライズレベルのエージェント

- `.github-private` リポジトリの `agents/` ディレクトリに配置
- 組織またはエンタープライズ全体で利用可能
- MCPサーバー設定を含めることができる

```yaml
---
name: org-security-reviewer
description: 組織のセキュリティ標準に基づくレビューエージェント
tools: ['read', 'search', 'security-scanner/*']
mcp-servers:
  security-scanner:
    type: 'local'
    command: 'security-tool'
    args: ['--config', 'org-config.json']
    tools: ["*"]
    env:
      API_KEY: ${{ secrets.SECURITY_API_KEY }}
---
```

### MCPサーバーの設定

組織/エンタープライズレベルのエージェントでは、`mcp-servers` プロパティを使用してMCPサーバーを設定できます。

**環境変数とシークレットの参照構文**:

- `${{ secrets.SECRET_NAME }}` - シークレット参照
- `${{ var.VARIABLE_NAME }}` - 環境変数参照

## 実用例

### 例1: テスト専門家エージェント

```markdown
---
name: test-specialist
description: テストカバレッジと品質を向上させ、本番コードを変更しないテスト専門家
tools: ["read", "edit", "search", "execute"]
handoffs:
  - label: コードレビューを依頼
    agent: code-reviewer
    prompt: 作成したテストコードをレビューしてください。
    send: false
---

# テスト専門家

包括的なテストを通じてコード品質を向上させることに焦点を当てたテスト専門家です。

## 責任範囲

- 既存のテストを分析し、カバレッジの欠落を特定する
- ベストプラクティスに従って、ユニットテスト、統合テスト、E2Eテストを作成する
- テスト品質を確認し、保守性向上の提案を行う
- テストが独立性、決定性、十分な文書化を確保する
- 特に要求されない限り、テストファイルのみに焦点を当て、本番コードを変更しない

## 実行ガイドライン

- テストの説明を明確にする
- 言語とフレームワークに適したテストパターンを使用する
- テストの可読性と保守性を優先する
```

### 例2: 実装計画策定エージェント

```markdown
---
name: implementation-planner
description: 詳細な実装計画と技術仕様をMarkdown形式で作成する
tools: ["read", "search", "fetch"]
model: Claude Sonnet 4
handoffs:
  - label: 実装を開始
    agent: agent
    prompt: 上記の計画を実装してください。
    send: false
---

# 実装計画策定の専門家

包括的な実装計画の作成に焦点を当てた技術計画の専門家です。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャドキュメントを作成する
- 明確なステップ、依存関係、タイムラインを含む実装計画を生成する
- API設計、データモデル、システム間の相互作用を文書化する
- 開発チームが従うことができる構造化された計画を含むMarkdownファイルを作成する

## 実行ガイドライン

- 明確な見出し、タスク分解、受け入れ基準で計画を構造化する
- テスト、デプロイメント、潜在的なリスクへの配慮を含める
- コードの実装ではなく、徹底的な文書化に焦点を当てる
```

### 例3: コードレビューエージェント

```markdown
---
name: code-reviewer
description: セキュリティ、パフォーマンス、品質の観点からコードをレビューする
tools: ["read", "search"]
---

# コードレビュー専門家

セキュリティ、パフォーマンス、コード品質の観点から徹底的なコードレビューを実施します。

## レビュープロセス

1. **セキュリティ分析**
   - 一般的な脆弱性（SQLインジェクション、XSS、CSRF）をチェック
   - 認証と認可のメカニズムを確認
   - 機密情報の取り扱いを評価

2. **パフォーマンス評価**
   - 非効率なアルゴリズムや不要なループを特定
   - データベースクエリの最適化の機会を見つける
   - メモリ使用パターンを確認

3. **コード品質チェック**
   - コーディング標準への準拠を確認
   - 命名規則とコメントの明確さを評価
   - コードの可読性と保守性を検証

4. **テストカバレッジ**
   - 既存のテストが変更をカバーしているか確認
   - 不足しているテストケースを特定

## 出力形式

レビュー結果は以下の形式で提供してください：

- **重大な問題**: セキュリティリスクやバグ
- **改善提案**: パフォーマンスとコード品質の向上
- **軽微な指摘**: スタイルや命名の改善
- **良い点**: 評価すべき実装部分
```

## まとめ: 重要な原則

カスタムエージェントを効果的に活用するための重要なポイント：

1. **明確な役割定義** - エージェントの目的と責任を明確にする
2. **最小権限の原則** - 必要最小限のツールのみを許可
3. **具体的な指示** - 実行可能で明確な指示を提供
4. **ハンドオフの活用** - エージェント間のスムーズな遷移を設計
5. **セキュリティ** - シークレット管理とツールアクセス制限を徹底
6. **モジュール化** - 再利用可能な指示を分離し、保守性を向上
7. **テストと改善** - 実際の使用を通じて継続的に改善
8. **カスタムインストラクションとの統合** - 共通ルールを分離し、重複を避ける
9. **パフォーマンス最適化** - タスクに応じた適切なモデルとツール選択
10. **ドキュメント化** - チーム内で共有するガイドラインを作成

これらのベストプラクティスに従うことで、効率的で安全、かつ保守しやすいカスタムエージェントを作成できます。
