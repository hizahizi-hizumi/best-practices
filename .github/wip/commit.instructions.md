---
description: 'Git のチーム開発フローにおけるコミット粒度・コミットメッセージ・履歴品質のルールとベストプラクティス'
applyTo: '**/*'
---

# 目的とスコープ
このドキュメントは、チーム開発における **コミット粒度**、**コミットメッセージ**、**履歴品質**（レビュー容易性・安全なロールバック・原因特定のしやすさ）を高めるためのルールとベストプラクティスを定義します。

# コミット粒度（コア原則）
- 無関係な変更は別コミットに分割する。
  - **理由**: レビューが速くなり、部分 revert や原因特定（`git bisect`）が容易になる。
- 1 コミットは「1 つの論理的変更」にする（1 文で説明できる単位）。
- 可能な範囲で、各コミットは単体でビルド・テスト可能な状態に寄せる。
  - **理由**: 中間コミットが壊れていると、調査・revert・cherry-pick のコストが増える。
- ステージングで意図した差分だけを含める（`git add -p` を活用する）。
- 「機械的変更（整形・リネーム・移動）」と「意味のある変更（ロジック・仕様）」を同じコミットに混ぜない。
- リファクタと挙動変更は原則分ける（ただし挙動変更を安全にするために必要な最小限のリファクタは例外）。
- ロジック変更と「フォーマットのみ」の変更を同一コミットに混ぜない。
- 依存関係更新と機能開発を同一コミットに束ねない（機能の前提なら例外として、その理由を本文に書く）。
- main に入る履歴に「WIP」「とりあえず」「あとで直す」コミットを残さない。
- チームが許容する場合は、作業中は `fixup!` / `squash!` を使い、マージ前に `--autosquash` で履歴を整形する。

# いつ分割するか（判断基準）
- 変更理由が異なる場合は分割する（例: バグ修正とリファクタ、依存更新と機能追加）。
- レビュアーが変わりそうなら分割する（例: UI と DB、フロントとバック）。
- ロールバックのリスクが異なるなら分割する（例: 安全な整理と挙動変更）。
- 差分を上から読んだときに、頭のコンテキストを頻繁に切り替える必要があるなら分割する。
- ファイル数が多くても「本質的な挙動変更」が少数ファイルなら、機械的変更は別コミットに分ける。
- 可能なら「リネーム/移動のみ」コミットには内容編集を入れない（diff が追いにくくなるため）。

# コミットメッセージ（メッセージ規約）
- リポジトリに既存のコミットメッセージ規約がある場合は、それに従う。
- 件名（1 行目）は短く具体的に、命令形で書く（例: “add”, “fix”, “remove”）。
- 重要な変更・リスクのある変更は本文で「何を」「なぜ」を補足する。
- 必要に応じて Issue/Ticket 番号を付ける（チーム規約に従う）。
- “update”“fix”“misc” など、対象が分からない曖昧な件名は避ける。

## 使用可能なコミットメッセージラベル（例）と使い分け
以下は **Conventional Commits 風**のラベル例です。リポジトリがこの形式を採用している場合に使用します（未採用なら、勝手に導入しない）。

- `feat`: ユーザー価値のある機能追加（新 API、画面の新機能、仕様追加）。
- `fix`: バグ修正（不具合・例外・回帰の修正）。
- `refactor`: 挙動を変えない内部改善（構造整理、責務分離、読みやすさ向上）。
- `perf`: パフォーマンス改善（計測や根拠があると望ましい）。
- `test`: テスト追加・修正（仕様確認、回帰テスト、テスト基盤）。
- `docs`: ドキュメントのみの変更（README、設計メモ、コメント整備を含めるかはチーム次第）。
- `style`: 見た目の整形のみ（フォーマッタ適用、空白、セミコロン、lint の自動修正など）。
- `chore`: ビルド/運用/周辺作業（依存更新、CI 設定、生成物更新、ツール設定、雑務）。
- `build`: ビルドシステムや依存解決に関わる変更（`package.json`/lockfile、Docker、ビルドスクリプト）。
- `ci`: CI/CD の変更（GitHub Actions、ジョブ、キャッシュ、デプロイ手順）。
- `dev`: ローカル開発体験向上（devcontainer、lint/format 設定、開発用スクリプト）。
  - ※ `dev` は標準ラベルではないため、チームで採用されている場合のみ使う。
- `revert`: 以前のコミットを取り消す（`git revert` が作る形式に合わせる）。

### ラベルの使用タイミング例
- フォーマットだけ直した → `style`
- リファクタして読みやすくした（挙動は不変）→ `refactor`
- ヌル入力で落ちるのを防いだ → `fix`
- 新しい検索条件を追加した → `feat`
- 依存を上げただけ → `chore` または `build`（チーム規約に従う）
- devcontainer を整備した → `dev`
- GitHub Actions を調整した → `ci`

## ラベル付きメッセージ例（採用している場合）
- `feat(api): タスク検索にフィルタを追加する`
- `fix(ui): モーダルの二重送信を防ぐ`
- `refactor(db): クエリ組み立てを抽出する`
- `style: フォーマッタ適用（挙動変更なし）`
- `chore: 依存関係を更新する`
- `dev: ローカル開発用スクリプトを追加する`
- `ci: テストジョブのキャッシュを改善する`

# 履歴品質（ブランチ → main）
- 「準備 → 変更 → テスト」の流れが読みやすいコミット列を目指す。
- 純粋なリファクタは先のコミットに置き、挙動変更コミットの差分を小さく見せる。
- 最終履歴は「論理的変更 1 つを 1 回の revert で戻せる」ことを意識する。
- チーム方針が squash merge の場合でも、作業中は小さく刻み、最終的に読みやすい履歴に整える。

# コミット分割・整形のコマンド例（代表パターン）
## 変更を小分けにステージしてコミットする（基本）
```bash
git add -p
git commit -m "refactor: バリデーション処理を抽出する"

git add -p
git commit -m "fix: null 入力で落ちないようにする"
```

## ステージから外す（ステージの調整）
```bash
git restore --staged path/to/file
# 旧コマンド（同等の用途）
git reset path/to/file
```

## 直前のコミットに差分を追加・修正する（履歴を書き換える）
```bash
git add -p
git commit --amend
```

## 混ぜた 1 コミットを「分割」して作り直す（ローカルで履歴を書き換える）
```bash
git reset --mixed HEAD~1

git add -p
git commit -m "refactor: ..."

git add -p
git commit -m "fix: ..."
```

## 複数コミットを並べ替え・結合・分割する（インタラクティブ rebase）
```bash
git rebase -i HEAD~5
```
- `pick`: そのまま
- `reword`: メッセージだけ修正
- `edit`: そのコミットで止めて分割/修正
- `squash` / `fixup`: 前のコミットにまとめる

## fixup/squash を使って最後に整形する（チームが許容する場合）
```bash
git commit --fixup <commit-sha>
git rebase -i --autosquash <base-branch>
```

## 一時退避しつつ部分的に作業を進める（混線防止）
```bash
git stash -p
git stash pop
```

# してはいけないこと
- 巨大な「全部入りコミット」を常態化させない。
- 理由なく「リポジトリ全体にフォーマッタ適用」を混ぜない（実施するなら専用コミットにする）。
- コミットを綺麗に見せる目的だけで、意味のある変更（命名・設計・挙動）を勝手に混ぜない。
