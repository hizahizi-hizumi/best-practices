---
description: '未コミット差分を分析し、コミット粒度ルールに沿ってコミット計画とコミットを作成'
agent: 'agent'
tools: ['read', 'runCommands']
---

# 未コミット差分のコミット（Commit Helper）

## 目的
作業ツリー（未コミット差分）を分析し、`.github/instructions/commit.instructions.md` のルールに沿って **適切な粒度のコミット列**を作成する。

## 入力（任意）
- ${input:baseBranch:main} : 比較・rebase の基準ブランチ（例: main / master / develop）
- ${input:scopeHint:} : 変更の目的・背景（例: 「検索条件の追加」「null 対応」「CI 修正」）

## 入力検証
- リポジトリ直下でない、または Git 管理下でない場合は停止して報告する。
- 未コミット差分が 0 の場合は停止して報告する。

---

## ワークフロー

### フェーズ 0: ルールの読み込み（必須）
1. #tool:read/readFile `.github/instructions/commit.instructions.md` を読み、以降の判断基準として適用する。

### フェーズ 1: 発見（差分の把握）
次の情報を収集し、要点を短く要約する。

- 変更状況
  - `git status --porcelain=v1 -uall`
  - `git diff --name-status`
  - `git diff --stat`
  - `git diff`（必要に応じて）
  - `git diff --staged`（必要に応じて）
- 既存のコミットメッセージ規約の推定（導入済みの規約を優先）
  - 直近 20 件程度のログを確認し、Conventional Commits 風の `type(scope): subject` が主流か判断する。
  - 例: `git log -20 --pretty=format:%s`

### フェーズ 2: 分類（コミット境界の設計）
差分を以下の観点で分類し、**混ぜない**コミット境界を引く。

- 論理単位: 1 コミット = 1 つの論理的変更（1 文で説明できる単位）
- 種別分離:
  - 機械的変更（整形・リネーム・移動） vs 意味のある変更（ロジック・仕様）
  - リファクタ（挙動不変） vs 挙動変更（機能追加・修正）
  - 依存更新 / CI / 開発環境 vs アプリ挙動
- リスク分離:
  - ロールバックのリスクが異なるものは分割する
  - レビュアーが変わりそうなら分割する
- 履歴品質:
  - 可能な範囲で各コミットが単体でビルド・テスト可能になるように順序を組む

### フェーズ 3: コミット計画の提示（実行前に必須）
次の形式で **提案コミット列**を出力する。

- 番号付きリスト
- 各コミットに以下を含める
  - コミット件名（1 行）
  - ラベル（採用されている場合のみ）と使用理由
  - 対象ファイル群（パスのまとまり）
  - 「機械的変更のみ」の場合は明示
  - 必要なら本文で書くべき「なぜ（why）」の要点

#### ラベル（Conventional Commits 風）を使う場合
- リポジトリがこの形式を採用している場合のみ使用する（未採用なら導入しない）。
- ラベル候補（`.github/instructions/commit.instructions.md` に従う）:
  - `feat`, `fix`, `refactor`, `perf`, `test`, `docs`, `style`, `chore`, `build`, `ci`, `dev`, `revert`

### フェーズ 4: コミットの実行（破壊的操作）
**このフェーズは、ユーザーが「実行して」と明示した場合のみ実施する。**  
実施する場合も、実行前に「実行するコマンド列」を提示し、直前で再確認する。

- コミットごとに、意図した差分だけが入るようにステージングする。
  - 例: `git add -p`（hunk 単位で分割）
  - 例: `git add <file...>`（ファイル単位で分割）
- コミットを作成する。
  - 例: `git commit -m "<subject>"`
  - 本文が必要なら複数 `-m` で「why」を追記する。
- 複数コミットの場合は、計画に沿って順に繰り返す。

### フェーズ 5: 検証（任意だが推奨）
プロジェクトの慣習に合わせて、実行可能な範囲で検証を行う（存在する場合のみ）。

- 例: `bundle exec rspec`, `rails test`
- 例: `npm test`, `pnpm test`, `yarn test`
- 例: `npm run lint`, `pnpm run lint`, `yarn lint`

---

## 要件（制約・禁止事項）
- 無関係な変更を 1 コミットに混ぜない。
- ロジック変更とフォーマットのみ変更を同一コミットに混ぜない。
- 依存更新と機能開発を同一コミットに束ねない（前提なら理由を本文に書く）。
- main に入る履歴に “WIP” コミットを残さない。
- リポジトリに既存規約がある場合、それを優先する。
- 破壊的操作（commit / rebase / reset など）を、ユーザーの明示なしに実行しない。

---

## 出力
### 常に出力するもの
- 差分の要約（変更ファイル、主な変更点、機械的変更の有無）
- 提案コミット列（件名・理由・対象ファイル群）

### ユーザーが実行を明示した場合に追加で出力するもの
- 実行するコマンド列（コミットごとに分割）
- 実行結果の要約（作成したコミット一覧）

---

## 失敗処理
- 途中でコマンドが失敗した場合は停止し、失敗理由と復旧案を提示する。
- コミット境界が不適切な場合は、履歴を壊さない選択肢（追加コミットでの修正）を優先し、履歴書き換えが必要ならリスクと手順を明示する。
