---
description: 'Bun（ランタイム/パッケージマネージャー/テストランナー/バンドラー）を使用するプロジェクトのベストプラクティス。再現性、セキュリティ、運用の卓越性を向上させる'
applyTo: '**/package.json, **/bun.lock*, **/bunfig.toml, **/*.ts, **/*.tsx, **/*.js, **/*.jsx, **/*.mjs, **/*.cjs, **/*.cts, **/*.mts, Dockerfile, **/Dockerfile.*, **/.github/workflows/**/*.yml, **/.github/workflows/**/*.yaml'
---

# Bun ベストプラクティス（Copilot向け）

## 目的と適用範囲

GitHub Copilotがコード、設定、CIをBunを使って生成または更新する際に、再現性、セキュリティ、保守性を保証する。

**適用範囲**: Bunをランタイム、パッケージマネージャー、テストランナー、またはバンドラーとして使用するすべてのプロジェクト。

## 基本原則

### 再現性
- ロックファイル（`bun.lock*`）を使用して再現可能なインストールを実現する
- ロックファイルをバージョン管理にコミットする
- CI環境ではロックファイルの更新を許可しない

**根拠**: ロックファイルはすべての環境で同一の依存関係バージョンを保証し、「私のマシンでは動く」問題を防ぐ。

### セキュリティ
- 依存関係のインストール中の任意コード実行を最小化する
- `trustedDependencies`で必要な依存関係のみを明示的に許可する
- パッケージを信頼する前にすべてのライフサイクルスクリプトをレビューする

**根拠**: 悪意のあるまたは侵害されたパッケージは、インストール中に任意のコードを実行でき、セキュリティリスクとなる。

### 型安全性の分離
- TypeScriptの実行と型チェックを分離する
- CIパイプラインで`tsc --noEmit`を明示的に実行する
- 型安全性をBunランタイムに依存しない

**根拠**: Bunは型チェックなしでTypeScriptを実行するため、TypeScriptが防ぐべきランタイムエラーを許してしまう。

### モノレポの整合性
- ワークスペースとリンカーの前提をチーム全体で統一する
- モノレポ設定でファントム依存関係を防ぐ
- パッケージ間の依存関係にはワークスペースプロトコルを使用する

### 環境設定
- 本番環境で`.env`の自動読み込みに依存しない
- CI/本番環境では環境変数を明示的に注入する
- シークレットをコードやバンドルから除外する

## 依存関係とCI

### インストールコマンド
- CI環境では`bun ci`または`bun install --frozen-lockfile`を使用する
- CIパイプラインで素の`bun install`は使用しない

**根拠**: 素の`bun install`はロックファイルを更新する可能性があり、再現不可能なビルドや予期しない依存関係の変更を引き起こす。

### ロックファイル管理
- `bun.lock*`ファイルをバージョン管理にコミットする
- ロックファイルが変更された場合CIを失敗させる設定にする
- 正当な理由なくロックファイルを変更するプルリクエストは却下する

### 本番環境の依存関係
- 本番イメージやジョブには`--production`フラグを使用する
- 本番環境からdevDependenciesを除外する
- 依存関係変更後に本番バンドルサイズを検証する

**根拠**: DevDependenciesは本番環境で不必要に攻撃対象領域とデプロイサイズを増加させる。

**✅ 良い例**
```yaml
# .github/workflows/ci.yml (例)
- run: bun ci
- run: bunx tsc --noEmit
- run: bun test
```

**❌ 悪い例（CIでロックファイルが更新される可能性がある）**
```yaml
- run: bun install
```

## セキュリティ

### ライフサイクルスクリプト
- ライフサイクルスクリプトを無差別に許可しない
- `trustedDependencies`に必要なパッケージのみをリストする
- `trustedDependencies`の変更にはコードレビューを要求する
- 各信頼済み依存関係の理由を文書化する

**根拠**: ライフサイクルスクリプトはインストール中に任意のコードを実行し、サプライチェーン攻撃を可能にする。

### プロトコルベースの依存関係
- `file:`プロトコル依存関係は極めて慎重に扱う
- `link:`プロトコル依存関係を注意深くレビューする
- `git:`と`github:`プロトコル依存関係を徹底的に監査する
- リポジトリ直接参照よりもnpmレジストリパッケージを優先する

**根拠**: 非レジストリプロトコルはセキュリティスキャンとバージョン検証メカニズムをバイパスする。

### サプライチェーン保護
- `minimumReleaseAge`を実装して新パッケージの採用を遅らせる
- 適切な経過日数の閾値を設定する（例: 3～7日）
- セキュリティと機能提供のニーズのバランスを取る

**根拠**: 新しく公開されたパッケージには、未発見の脆弱性が含まれているか、侵害されている可能性がある。

### 依存関係のオーバーライド
- `overrides`は緊急のセキュリティ修正のみに使用する
- 各オーバーライドについてCVE番号または互換性問題を文書化する
- アップストリームパッケージが更新されたらオーバーライドを削除する
- オーバーライドを定期的にレビューする（月次推奨）

**✅ 良い例（最小限の信頼）**
```json
{
  "trustedDependencies": ["my-trusted-package"]
}
```

**✅ 良い例（緊急修正のオーバーライド）**
```json
{
  "overrides": {
    "some-transitive-dep": "1.2.3"
  }
}
```

**❌ 悪い例（過度に寛容）**
```json
{
  "trustedDependencies": ["*"]
}
```

## ワークスペースとモノレポ

### ワークスペース依存関係
- パッケージ間依存関係には`workspace:*`プロトコルを使用する
- または、semver対応の参照には`workspace:^`を使用する
- ワークスペース依存関係に相対ファイルパスは使用しない
- パッケージを移動する際はすべてのワークスペース参照を更新する

**根拠**: ワークスペースプロトコルは適切な依存関係解決を保証し、バージョン競合を防ぐ。

### パッケージ境界
- パッケージのエントリーポイント（main/exports）からのみインポートする
- `src`や`dist`ディレクトリから直接インポートしない
- パッケージ間で明確な公開APIコントラクトを維持する
- 各パッケージを独立したモジュールとして扱う

**根拠**: 直接インポートはパッケージ境界をバイパスし、密結合を生み出し、独立したバージョニングを妨げる。

### リンカー設定
- `bunfig.toml`でリンカー（`isolated`または`hoisted`）を明示的に設定する
- すべての環境で同じリンカー設定を使用する
- プロジェクトREADMEにリンカーの選択を文書化する
- デプロイ前に設定されたリンカーでテストする

**根拠**: 一貫性のないリンカー設定は、ファントム依存関係と環境固有の障害を引き起こす。

**✅ 良い例（ワークスペースプロトコル）**
```json
{
  "workspaces": ["packages/*"],
  "dependencies": {
    "@acme/core": "workspace:*"
  }
}
```

**❌ 悪い例（パッケージ境界の破壊）**
```ts
import { internalThing } from "../../packages/core/src/internal";
```

## 設定管理

### プロジェクト設定
- プロジェクト設定を`bunfig.toml`に集約する
- `bunfig.toml`をバージョン管理にコミットする
- チーム全体で設定を共有する
- 自明でない設定選択を文書化する

### 環境変数
- `.env`ファイルは開発時の利便性のみとして扱う
- CI/本番環境では環境変数を明示的に注入する
- シークレットを含む`.env`ファイルは決してコミットしない
- 本番環境ではプラットフォーム固有のシークレット管理を使用する

**根拠**: `.env`の自動読み込みは開発専用であり、本番環境では明示的な設定が必要である。

### シークレット管理
- シークレットをコードやバンドルから除外する
- すべてのシークレットには環境変数を使用する
- 起動時に必須シークレットの存在を検証する
- シークレットを定期的にローテーションする

### 本番環境での.envの無効化
- 本番ビルド用に`bunfig.toml`で`env = false`を設定する
- 誤った`.env`ファイルへの依存を防ぐ
- 環境変数の要件を文書化する

**✅ 良い例（CI/本番環境で.envを無効化）**
```toml
# bunfig.toml
env = false
```

## TypeScript統合

### 型チェックの分離
- 型安全性をBunランタイムに依存しない
- 別のステップで明示的な型チェックを実行する
- 型エラーでCIビルドを失敗させる
- コミット前に型チェックを行う

**根拠**: Bunは型チェックなしでTypeScriptを実行し、型エラーをランタイムまで遅延させる。

### CIでの型チェック
- すべてのCIパイプラインで`bunx tsc --noEmit`を実行する
- テスト実行前に型チェックを実行する
- 厳格なTypeScriptオプションを設定する
- 型チェック失敗時はマージをブロックする

### 開発ワークフロー
- package.jsonに`typecheck`スクリプトを追加する
- 開発中は型チェックをウォッチモードで実行する
- 型チェックをpre-commitフックに統合する
- エディターのTypeScript統合を使用する

### 型定義
- devDependenciesに`@types/bun`をインストールする
- `@types/*`パッケージを最新に保つ
- 未使用の型定義パッケージを削除する
- カスタム型定義を文書化する

**✅ 良い例**
```json
{
  "scripts": {
    "dev": "bun run src/index.ts",
    "typecheck": "bunx tsc --noEmit",
    "test": "bun test"
  }
}
```

**❌ 悪い例（型チェックなし）**
```json
{
  "scripts": {
    "check": "bun run src/index.ts"
  }
}
```

## Bunでのテスト

### テストランナー
- `bun test`を主要なテストランナーとして使用する
- スピードよりもテストの安定性を優先する
- 遅いテストのタイムアウトを明示的に設定する
- CIでは詳細出力でテストを実行する

### 不安定なテストの防止
- `--randomize`フラグを使用して順序依存性を検出する
- 再現可能なテスト実行のために`--seed`値を設定する
- 共有状態を持つテストを分離する
- 既知の不安定なテストと軽減策を文書化する

**根拠**: 順序依存のテストはバグを隠蔽し、コード変更とは無関係なCI失敗を引き起こす。

### 並列実行
- I/O操作を含むテストは直列化する
- データベーステストにはテスト分離を使用する
- 外部サービス依存関係をモック化する
- 共有ファイルシステム状態を避ける

### テストの整理
- 関連するテストをdescribeブロックにグループ化する
- テストを説明的に命名する（何を、期待される結果を）
- テストファイルはソースファイルに隣接または`__tests__`ディレクトリに配置する
- 命名規則に従う: `*.test.ts`または`*.spec.ts`

## ビルド設定

### ターゲットとフォーマット
- `target`オプション（browser/node/bun）を明示的に指定する
- `format`オプション（esm/cjs/iife）を明示的に指定する
- ターゲットを実際のランタイム環境に合わせる
- デプロイ前にビルド出力の互換性を検証する

**根拠**: 暗黙のデフォルトはターゲット環境と互換性のない出力を生成する可能性がある。

### 環境変数のインライン化
- ビルド中の環境変数のインライン化を最小化する
- 公開の、機密性のない値のみをインライン化する
- どの変数がインライン化されるかを文書化する
- インライン化された値にシークレットが含まれていないことを検証する

**根拠**: インライン化された変数はバンドル内で永続的となり、再ビルドなしでは変更できない。

### ビルドの最適化
- 本番ビルドでは最小化を有効にする
- デバッグ用にソースマップを生成する
- バンドルサイズを定期的に分析する
- 適切な場合は大きなバンドルを分割する

### 出力検証
- ターゲット環境でビルド成果物をテストする
- 外部依存関係が正しく解決されることを検証する
- バンドルサイズを閾値と照合する
- 本番バンドルに開発コードが含まれていないことを確認する

## シェル実行の安全性

### 入力のサニタイズ
- ユーザー入力をシェルコマンドに直接渡さない
- すべての外部入力を検証およびサニタイズする
- 可能な場合はパラメータ化された実行を使用する
- シェルコマンドよりもBun APIを優先する

**根拠**: サニタイズされていない入力はコマンドインジェクション攻撃を可能にする。

### シェルスクリプトのベストプラクティス
- シェルスクリプト内のすべての変数をクォートする
- エラー検出のために`set -euo pipefail`を使用する
- 終了コードを明示的にチェックする
- デバッグのためにコマンド実行をログに記録する

### サブプロセス実行
- 安全な実行のためにBunの`$`テンプレートリテラルを使用する
- 文字列連結で`bash -c`を避ける
- 特殊文字を適切にエスケープする
- サブプロセスに適切なタイムアウトを設定する

## Docker統合

### ベースイメージ
- 公式の`oven/bun`イメージを使用する
- 特定のBunバージョンタグをピン留めする（`latest`ではなく）
- セキュリティパッチのためにベースイメージを定期的に更新する
- DockerfileコメントにBunバージョンを文書化する

**根拠**: バージョンピン留めは再現可能なビルドを保証し、`latest`タグは破壊的変更をもたらす可能性がある。

### 依存関係のキャッシュ
- ソースコードの前に`package.json`と`bun.lock*`をコピーする
- アプリケーションコードをコピーする前に`bun install`を実行する
- 依存関係のためにDockerレイヤーキャッシュを活用する
- 依存関係が変更された場合のみキャッシュを無効化する

### ロックファイルの強制
- Dockerfileでは常に`--frozen-lockfile`フラグを使用する
- ロックファイルが変更された場合ビルドを失敗させる
- イメージ内で素の`bun install`は実行しない

### マルチステージビルド
- ビルドとランタイムに別々のステージを使用する
- 最終ステージでは本番依存関係のみをインストールする
- ランタイム依存関係には`--production`フラグを使用する
- 必要な成果物のみをランタイムステージにコピーする

**根拠**: マルチステージビルドは最終イメージサイズと攻撃対象領域を削減する。

### イメージの最適化
- レイヤー数を最小化する
- 最終ステージ前に不要なファイルを削除する
- `.dockerignore`を使用してファイルを除外する
- イメージの脆弱性を定期的にスキャンする

**✅ 良い例（依存関係を最初にコピー）**
```dockerfile
COPY package.json bun.lock ./
RUN bun install --frozen-lockfile --production
```

**❌ 悪い例（キャッシュ利用が不十分）**
```dockerfile
COPY . .
RUN bun install
```

## 検証と確認

### CIパイプラインの検証
- パイプラインを設定する: `bun ci` → `bunx tsc --noEmit` → `bun test`
- マージ前にすべてのステップが通過することを確認する
- 型チェック前にリントを実行する
- カバレッジレポート付きでテストを実行する

### 依存関係の変更
- パッケージ追加後の`trustedDependencies`への影響をレビューする
- 更新後も`overrides`が必要かどうかを検証する
- `minimumReleaseAge`が新しい依存関係に影響することを確認する
- 依存関係更新後にセキュリティ監査を実行する

### プレコミットチェックリスト
- 依存関係が変更された場合ロックファイルがコミットされている
- 型チェックがローカルで通過する
- すべてのテストが通過する
- コードや設定にシークレットがない
- ターゲット環境でビルドが成功する

### プレマージチェックリスト
- CIパイプラインがグリーン
- コードレビューが完了している
- セキュリティ変更はセキュリティチームによってレビューされている
- ドキュメントが更新されている
- 破壊的変更がチェンジログに文書化されている

## よくあるアンチパターン

### 避けるべき: ロックファイルの無視
**悪い**: `bun install`を実行してロックファイルの変更をコミットしない
**良い**: 依存関係変更の直後にロックファイルの変更をコミットする

### 避けるべき: すべての依存関係を信頼する
**悪い**: `trustedDependencies: ["*"]`を設定する
**良い**: 必要なパッケージのみを明示的にリストする

### 避けるべき: 型チェックのスキップ
**悪い**: 検証に`bun run`のみに依存する
**良い**: CIで常に`tsc --noEmit`を実行する

### 避けるべき: 本番環境での.env
**悪い**: `.env`ファイルを本番環境にデプロイする
**良い**: プラットフォームツールを通じて環境変数を注入する

### 避けるべき: 未定義のビルドターゲット
**悪い**: デフォルトのビルド設定を使用する
**良い**: `target`と`format`オプションを明示的に設定する

## ツールバージョン

- Bun: >= 1.0.0（CIでは正確なバージョンを指定）
- TypeScript: >= 5.0.0（最新の型システム機能のため）
- Node.js互換性: Node.js APIを使用している場合は検証する

## 参考資料

- [Bun公式ドキュメント](https://bun.sh/docs)
- [Bun Runtime APIs](https://bun.sh/docs/api)
- [Bun Test Runner](https://bun.sh/docs/cli/test)
- [Bun Bundler](https://bun.sh/docs/bundler)
