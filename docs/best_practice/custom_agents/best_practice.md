# VS Code Copilot カスタムエージェントのベストプラクティス

## 概要

カスタムエージェントは、特定の開発タスクに特化したAI設定を提供する仕組みです。エージェントごとに利用可能なツール、指示、動作を定義でき、計画、実装、レビューなどの役割に応じた専用設定を作成できます。

## カスタムエージェントの基本構造

### ファイル形式と配置

- **ファイル拡張子**: `.agent.md`
- **ワークスペースレベル**: `.github/agents/` ディレクトリに配置
- **ユーザープロファイルレベル**: すべてのワークスペースで利用可能
- **組織/エンタープライズレベル**: `.github-private` リポジトリの `agents/` ディレクトリ（組織全体で利用可能）

### ファイル構造

カスタムエージェントファイルは、YAMLフロントマターとMarkdownボディで構成されます。

```markdown
---
name: agent-name
description: エージェントの目的と機能の説明
tools: ["read", "edit", "search"]
model: Claude Sonnet 4
target: vscode
---

# エージェントの指示

エージェントの動作、専門知識、タスクの実行方法を記述します。
```

## YAML フロントマターのベストプラクティス

### 必須プロパティ

#### description（必須）

- エージェントの目的と機能を明確に記述
- チャット入力フィールドのプレースホルダーテキストとして表示される
- 具体的で簡潔な説明を心がける

```yaml
description: テストカバレッジと品質を向上させ、本番コードを変更しないテスト専門家
```

### オプションプロパティ

#### name

- エージェントの表示名
- 省略時はファイル名（拡張子を除く）が使用される
- 目的が明確でわかりやすい名前を付ける

```yaml
name: test-specialist
```

#### tools

- エージェントが使用できるツールのリスト
- **省略時**: すべての利用可能なツールが有効化される
- **空リスト `[]`**: すべてのツールを無効化
- **特定のリストを指定**: 指定したツールのみ有効化

```yaml
# 読み取り専用タスク向け
tools: ["read", "search", "fetch"]

# 実装タスク向け
tools: ["read", "edit", "search", "execute"]

# すべてのツールを有効化（明示的）
tools: ["*"]
```

**利用可能なツールエイリアス**:

| エイリアス | 説明                                   |
| ---------- | -------------------------------------- |
| `read`     | ファイル内容の読み取り                 |
| `edit`     | ファイルの編集（str_replace等）        |
| `search`   | ファイルやテキストの検索（grep, glob） |
| `execute`  | シェルコマンドの実行                   |
| `agent`    | 他のカスタムエージェントの呼び出し     |
| `web`      | URLからのコンテンツ取得、Web検索       |
| `todo`     | 構造化タスクリストの管理               |

**MCPサーバーツールの指定**:

```yaml
# 特定のMCPツール
tools: ["read", "edit", "github/list-repos"]

# MCPサーバーのすべてのツール
tools: ["playwright/*", "github/*"]
```

#### model

- 使用するAIモデルを指定
- 省略時は現在選択されているモデルが使用される

```yaml
model: Claude Sonnet 4
```

#### target

- エージェントの利用環境を制限
- 値: `vscode` または `github-copilot`
- 省略時は両方の環境で利用可能

```yaml
target: vscode
```

#### infer

- タスクコンテキストに基づく自動エージェント選択の有効化
- `false` の場合、手動選択が必要
- デフォルト: `true`

```yaml
infer: false
```

#### handoffs

- エージェント間の遷移を定義
- 次のステップを提案するボタンとして表示
- 順次ワークフローの作成に有効

```yaml
handoffs:
  - label: 実装を開始
    agent: implementation
    prompt: 上記で概説した計画を実装してください。
    send: false
```

#### argument-hint

- チャット入力フィールドに表示されるヒントテキスト
- ユーザーがエージェントとどう対話すべきかを案内

```yaml
argument-hint: "機能名または説明を入力してください"
```

## エージェント本体（プロンプト）のベストプラクティス

### 明確な役割定義

エージェントの役割、責任、実行方法を明確に記述します。

```markdown
# 計画策定の専門家

あなたは技術計画の専門家で、包括的な実装計画の作成に特化しています。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャドキュメントを作成する
- 明確なステップ、依存関係、タイムラインを含む実装計画を生成する
- API設計、データモデル、システム間の相互作用を文書化する

## 実行ガイドライン

- 明確な見出し、タスク分解、受け入れ基準で計画を構造化する
- テスト、デプロイメント、潜在的なリスクへの配慮を含める
- コードの実装ではなく、徹底的な文書化に焦点を当てる
```

### タスク固有の指示

エージェントが実行すべきタスクの詳細な手順を提供します。

```markdown
## コードレビュープロセス

1. **セキュリティレビュー**: 一般的な脆弱性（SQLインジェクション、XSS、認証の問題）をチェック
2. **パフォーマンス分析**: 非効率なアルゴリズム、不要なループ、最適化の機会を特定
3. **コード品質**: コーディング標準への準拠、命名規則、コメントの明確さを確認
4. **テストカバレッジ**: 既存のテストが変更をカバーしているか評価
5. **ドキュメント**: 変更がドキュメントされ、理解しやすいことを確認
```

### 制約と境界の明示

エージェントが何をすべきで、何をすべきでないかを明確にします。

```markdown
## 制約事項

- テストファイルのみに焦点を当て、特に要求されない限り本番コードを変更しない
- すべてのテストは独立性、決定性、十分な文書化を確保する
- 言語とフレームワークに適したテストパターンを使用する
```

### Markdownリンクによる参照

他のファイルやカスタムインストラクションを参照して、重複を避けます。

```markdown
詳細なコーディング標準については、[プロジェクト標準](../../coding-standards.md)を参照してください。
```

### ツール参照の記法

エージェント本文でツールを参照する場合は、`#tool:<tool-name>` 構文を使用します。

```markdown
プロジェクト構造を理解するために、#tool:search を使用してコードベースを探索してください。
```

## ツール選択のベストプラクティス

### タスクに応じたツール選択

| タスクタイプ     | 推奨ツール                          | 理由                             |
| ---------------- | ----------------------------------- | -------------------------------- |
| 計画・分析       | `read`, `search`, `fetch`           | 読み取り専用で、誤った変更を防止 |
| 実装             | `read`, `edit`, `search`, `execute` | コード変更と実行が必要           |
| レビュー         | `read`, `search`                    | コード確認のみ、変更は不要       |
| テスト作成       | `read`, `edit`, `search`, `execute` | テストファイルの作成と実行       |
| ドキュメント作成 | `read`, `edit`, `search`            | ドキュメントファイルの作成と更新 |

### ツールの段階的な有効化

必要最小限のツールから開始し、必要に応じて追加します。

```yaml
# 初期段階: 読み取り専門
tools: ["read", "search"]

# 次段階: 編集機能を追加
tools: ["read", "search", "edit"]

# 完全実装: すべてのツール
tools: ["*"]
```

### MCPツールの活用

Model Context Protocol (MCP) サーバーのツールを使用する場合は、名前空間を指定します。

```yaml
tools: 
  - "read"
  - "edit"
  - "github/list-repos"      # 特定のGitHubツール
  - "playwright/navigate"     # 特定のPlaywrightツール
```

## ハンドオフのベストプラクティス

### 順次ワークフローの設計

エージェント間の論理的な遷移を設計します。

```yaml
handoffs:
  - label: 計画を確認
    agent: reviewer
    prompt: この実装計画をレビューし、改善提案をしてください。
    send: false
  - label: 実装を開始
    agent: implementation
    prompt: 計画に基づいてコードを実装してください。
    send: false
```

### 自動送信の使い分け

- `send: false`: ユーザーがプロンプトを確認・編集してから送信（推奨）
- `send: true`: プロンプトを自動送信（確実な次ステップの場合のみ）

```yaml
handoffs:
  - label: 失敗テストを作成
    agent: test-writer
    prompt: 要件に基づいて失敗するテストケースを作成してください。
    send: false
  - label: テストを合格させる
    agent: implementation
    prompt: 上記のテストが合格するようにコードを実装してください。
    send: false
```

## 実用例

### 例1: テスト専門家エージェント

```markdown
---
name: test-specialist
description: テストカバレッジと品質を向上させ、本番コードを変更しないテスト専門家
tools: ["read", "edit", "search", "execute"]
handoffs:
  - label: コードレビューを依頼
    agent: code-reviewer
    prompt: 作成したテストコードをレビューしてください。
    send: false
---

# テスト専門家

包括的なテストを通じてコード品質を向上させることに焦点を当てたテスト専門家です。

## 責任範囲

- 既存のテストを分析し、カバレッジの欠落を特定する
- ベストプラクティスに従って、ユニットテスト、統合テスト、E2Eテストを作成する
- テスト品質を確認し、保守性向上の提案を行う
- テストが独立性、決定性、十分な文書化を確保する
- 特に要求されない限り、テストファイルのみに焦点を当て、本番コードを変更しない

## 実行ガイドライン

- テストの説明を明確にする
- 言語とフレームワークに適したテストパターンを使用する
- テストの可読性と保守性を優先する
```

### 例2: 実装計画策定エージェント

```markdown
---
name: implementation-planner
description: 詳細な実装計画と技術仕様をMarkdown形式で作成する
tools: ["read", "search", "fetch"]
model: Claude Sonnet 4
handoffs:
  - label: 実装を開始
    agent: agent
    prompt: 上記の計画を実装してください。
    send: false
---

# 実装計画策定の専門家

包括的な実装計画の作成に焦点を当てた技術計画の専門家です。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャドキュメントを作成する
- 明確なステップ、依存関係、タイムラインを含む実装計画を生成する
- API設計、データモデル、システム間の相互作用を文書化する
- 開発チームが従うことができる構造化された計画を含むMarkdownファイルを作成する

## 実行ガイドライン

- 明確な見出し、タスク分解、受け入れ基準で計画を構造化する
- テスト、デプロイメント、潜在的なリスクへの配慮を含める
- コードの実装ではなく、徹底的な文書化に焦点を当てる
```

### 例3: コードレビューエージェント

```markdown
---
name: code-reviewer
description: セキュリティ、パフォーマンス、品質の観点からコードをレビューする
tools: ["read", "search"]
---

# コードレビュー専門家

セキュリティ、パフォーマンス、コード品質の観点から徹底的なコードレビューを実施します。

## レビュープロセス

1. **セキュリティ分析**
   - 一般的な脆弱性（SQLインジェクション、XSS、CSRF）をチェック
   - 認証と認可のメカニズムを確認
   - 機密情報の取り扱いを評価

2. **パフォーマンス評価**
   - 非効率なアルゴリズムや不要なループを特定
   - データベースクエリの最適化の機会を見つける
   - メモリ使用パターンを確認

3. **コード品質チェック**
   - コーディング標準への準拠を確認
   - 命名規則とコメントの明確さを評価
   - コードの可読性と保守性を検証

4. **テストカバレッジ**
   - 既存のテストが変更をカバーしているか確認
   - 不足しているテストケースを特定

## 出力形式

レビュー結果は以下の形式で提供してください：

- **重大な問題**: セキュリティリスクやバグ
- **改善提案**: パフォーマンスとコード品質の向上
- **軽微な指摘**: スタイルや命名の改善
- **良い点**: 評価すべき実装部分
```

## 組織レベルのベストプラクティス

### 組織/エンタープライズレベルのエージェント

- `.github-private` リポジトリの `agents/` ディレクトリに配置
- 組織またはエンタープライズ全体で利用可能
- MCPサーバー設定を含めることができる

```yaml
---
name: org-security-reviewer
description: 組織のセキュリティ標準に基づくレビューエージェント
tools: ['read', 'search', 'security-scanner/*']
mcp-servers:
  security-scanner:
    type: 'local'
    command: 'security-tool'
    args: ['--config', 'org-config.json']
    tools: ["*"]
    env:
      API_KEY: ${{ secrets.SECURITY_API_KEY }}
---
```

### MCPサーバーの設定

組織/エンタープライズレベルのエージェントでは、`mcp-servers` プロパティを使用してMCPサーバーを設定できます。

```yaml
mcp-servers:
  custom-mcp:
    type: 'local'
    command: 'some-command'
    args: ['--arg1', '--arg2']
    tools: ["*"]
    env:
      ENV_VAR_NAME: ${{ secrets.SECRET_NAME }}
      OTHER_VAR: ${{ var.VARIABLE_NAME }}
```

**環境変数とシークレットの参照構文**:

- `${{ secrets.SECRET_NAME }}`: シークレット参照
- `${{ var.VARIABLE_NAME }}`: 環境変数参照
- `$SECRET_NAME`: 環境変数のみ（GitHub Actions構文）
- `${SECRET_NAME}`: Claude Code構文

## 共通の落とし穴と回避策

### 1. ツール権限が広すぎる

**問題**: すべてのエージェントにすべてのツールを許可

```yaml
# 避けるべき
tools: ["*"]
```

**解決策**: タスクに必要な最小限のツールのみを許可

```yaml
# 推奨
tools: ["read", "search"]  # 分析タスク
```

### 2. 不明確な指示

**問題**: エージェントの動作が曖昧

```markdown
コードを改善してください。
```

**解決策**: 具体的で実行可能な指示

```markdown
## 改善ガイドライン

1. 冗長なコードを削除する
2. 複雑な関数をより小さな関数に分割する
3. 適切なエラーハンドリングを追加する
4. パフォーマンス上のボトルネックを特定する
```

### 3. ハンドオフの欠如

**問題**: エージェント間の遷移が手動で煩雑

**解決策**: 適切なハンドオフを定義

```yaml
handoffs:
  - label: 次のステップへ
    agent: next-agent
    prompt: 前のステップで生成された内容を確認し、次の作業を進めてください。
    send: false
```

### 4. モデル選択の考慮不足

**問題**: すべてのタスクに同じモデルを使用

**解決策**: タスクの複雑さに応じてモデルを選択

```yaml
# 複雑な分析タスク
model: Claude Sonnet 4

# シンプルなフォーマット変更
model: Claude Haiku
```

## セキュリティのベストプラクティス

### 1. シークレット管理

- MCPサーバー設定でシークレットを参照する場合、リポジトリの "copilot" 環境に設定
- 平文でシークレットをファイルに含めない

```yaml
env:
  API_KEY: ${{ secrets.API_KEY }}  # 安全
  API_KEY: "my-secret-key"         # 危険
```

### 2. ツールアクセス制限

- 必要最小限のツールのみを許可
- `execute` ツールの使用には特に注意

```yaml
# セキュリティレビューエージェント
tools: ["read", "search"]  # executeは不要
```

### 3. 環境の分離

- `target` プロパティを使用して実行環境を制限

```yaml
target: vscode  # VS Codeのみで利用
```

## パフォーマンスのベストプラクティス

### 1. ツールの効率的な選択

- 不要なツールを含めない（処理が遅くなる可能性）
- タスクに特化したツールセットを定義

### 2. プロンプトサイズの管理

- プロンプトは最大30,000文字
- 大きなファイルは参照リンクを使用

```markdown
詳細は[詳細ガイド](./detailed-guide.md)を参照してください。
```

### 3. モデル選択の最適化

- 軽量タスクには軽量モデル（Haiku）を使用
- 複雑なタスクのみ高性能モデル（Sonnet, Opus）を使用

## 保守性とスケーラビリティ

### 1. モジュール化

- 再利用可能な指示は別ファイルに分離
- Markdownリンクで参照

```markdown
共通のコーディング標準については、[コーディング標準](../instructions/coding-standards.instructions.md)を参照してください。
```

### 2. バージョン管理

- エージェントファイルはGitで管理
- 変更履歴を追跡
- ブランチやタグで異なるバージョンを管理

### 3. ドキュメント化

- 各エージェントの目的と使用方法を明確に記述
- チーム内で共有するガイドラインを作成

### 4. 命名規則の統一

- エージェント名は目的を明確に反映
- ファイル名はケバブケース（例: `test-specialist.agent.md`）

## テストとデバッグ

### 1. エージェントのテスト

- 作成したエージェントを実際のタスクでテスト
- 想定外の動作を確認し、指示を改善

### 2. ハンドオフのテスト

- エージェント間の遷移が適切に機能するか確認
- プロンプトの内容が次のエージェントに適切に渡されるか検証

### 3. ツール利用の検証

- 指定したツールが適切に使用されているか確認
- 不要なツールが使用されていないか確認

## カスタムインストラクションとの連携

カスタムエージェントはカスタムインストラクションと組み合わせることで、さらに強力になります。

### カスタムインストラクションの種類

1. **`.github/copilot-instructions.md`**
   - ワークスペース全体に自動適用される
   - プロジェクト全体の共通ルールを定義

2. **`.instructions.md` ファイル**
   - ファイルタイプや場所に応じて条件付きで適用
   - `applyTo` グロブパターンで適用範囲を制御

3. **`AGENTS.md` ファイル**
   - 複数のAIエージェントを使用するワークスペース向け
   - ワークスペース全体またはサブフォルダーに適用

### エージェントでカスタムインストラクションを参照

```markdown
---
name: code-reviewer
description: コーディング標準に従ってコードをレビュー
tools: ["read", "search"]
---

# コードレビュー専門家

このエージェントは、プロジェクトのコーディング標準を厳密に適用します。

詳細なコーディング標準については、[コーディング標準](../../.github/instructions/coding-standards.instructions.md)を参照してください。

## レビュープロセス

1. コーディング標準への準拠を確認
2. セキュリティ上の問題を特定
3. パフォーマンスの最適化の機会を提案
```

### ベストプラクティス

- **重複を避ける**: 共通のルールはカスタムインストラクションに記述し、エージェントから参照
- **エージェント固有の指示のみを記述**: エージェント特有の動作のみをエージェントファイルに含める
- **階層的な組織化**: プロジェクト全体 → ファイルタイプ → エージェント固有の順で指示を構造化

## 背景エージェントとクラウドエージェントとの統合

### 背景エージェント（Background Agents）

カスタムエージェントは背景エージェントとして実行でき、自律的なタスクを実行できます。

```markdown
---
name: test-generator
description: 自動的にテストケースを生成する背景エージェント
tools: ["read", "edit", "search", "execute"]
---

# テストケース自動生成エージェント

このエージェントは、新しいコードに対して自動的にテストケースを生成します。

## 実行プロセス

1. 新規または変更されたファイルを検出
2. ファイルの機能を分析
3. 適切なテストケースを生成
4. テストを実行して検証
```

### クラウドエージェント（Cloud Agents）

GitHub Copilot coding agentなどのクラウドエージェントでもカスタムエージェントを使用できます。

- リモートインフラストラクチャで実行
- GitHub Actions環境でコードを探索、変更、テスト
- プルリクエストとコラボレーション機能を活用

## プロンプトファイルとの統合

カスタムエージェントはプロンプトファイルと組み合わせて使用できます。

### プロンプトファイルでエージェントを指定

```markdown
---
description: Reactフォームコンポーネントを生成
agent: implementation
tools: ["read", "edit", "search"]
---

以下の要件に基づいてReactフォームコンポーネントを作成してください：

- フォーム名: ${input:formName}
- バリデーションライブラリ: Zod
- スタイリング: Tailwind CSS
```

### ツールリストの優先順位

ツールの利用可能性は以下の順で決定されます:

1. プロンプトファイルで指定されたツール（最優先）
2. プロンプトファイルで参照されたカスタムエージェントのツール
3. 選択されたエージェントのデフォルトツール

## まとめ

カスタムエージェントを効果的に活用するための重要なポイント：

1. **明確な役割定義**: エージェントの目的と責任を明確にする
2. **最小権限の原則**: 必要最小限のツールのみを許可
3. **具体的な指示**: 実行可能で明確な指示を提供
4. **ハンドオフの活用**: エージェント間のスムーズな遷移を設計
5. **セキュリティ**: シークレット管理とツールアクセス制限を徹底
6. **モジュール化**: 再利用可能な指示を分離し、保守性を向上
7. **テストと改善**: 実際の使用を通じて継続的に改善
8. **カスタムインストラクションとの統合**: 共通ルールを分離し、重複を避ける
9. **背景/クラウドエージェントの活用**: 自律的なタスクやリモート実行に対応
10. **プロンプトファイルとの組み合わせ**: 再利用可能なワークフローを構築

これらのベストプラクティスに従うことで、効率的で安全、かつ保守しやすいカスタムエージェントを作成できます。
