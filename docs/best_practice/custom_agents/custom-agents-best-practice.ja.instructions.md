````instructions
---
description: 'VS Code Copilot のカスタムエージェント作成のベストプラクティス'
applyTo: '**/.github/agents/**/*.agent.md, **/.github/chatmodes/**/*.chatmode.md'
---

# カスタムエージェント作成ガイドライン

VS Code で特定の開発タスクに特化したカスタムエージェントを作成するためのベストプラクティスである。

## 基本原則

### 1. 最小権限の原則
- 必要最小限のツールのみを付与する
- 特に `execute` ツールは慎重に使用する
- 読み取り専用タスクには `["read", "search"]` のみを付与する

### 2. 明確な役割定義
- エージェントの役割を一文で説明する
- 責任範囲を明確に定める
- 何をすべきか、何をすべきでないかを明示する

### 3. 具体的な指示
- 実行可能で具体的な手順を提供する
- 抽象的な表現を避ける
- 出力形式を明確に指定する

## YAML Front Matter

### description (必須)

エージェントの目的と機能を 50〜100 文字で説明する。

```yaml
# 推奨
description: プロダクションコードを変更せずにテストカバレッジを向上させるテスト専門家

# 非推奨
description: テストエージェント
```

**理由**: チャット入力フィールドにプレースホルダーとして表示される

### name

明確で目的を反映した名前を kebab-case で指定する (例: `test-specialist`)。

### tools - タスク別の最小権限設定

**必要最小限のツールのみを付与する。**

| タスクの種類 | 推奨ツール | 理由 |
|----------|----------|------|
| 計画・分析 | `["read", "search", "fetch"]` | 読み取り専用、意図しない変更を防ぐ |
| 実装 | `["read", "edit", "search", "execute"]` | コード変更と実行が必要である |
| レビュー | `["read", "search"]` | 確認のみ、変更不要である |

```yaml
# 推奨 - 読み取り専用
tools: ["read", "search", "fetch"]

# 非推奨 - 全権限
tools: ["*"]
```

**理由**: セキュリティリスクを最小化し、エージェントの役割を明確にする

**利用可能なツールエイリアス**:
- `read` - ファイル内容の読み取り
- `edit` - ファイルの編集 (str_replace など)
- `search` - ファイルやテキストの検索 (grep、glob)
- `execute` - シェルコマンドの実行
- `agent` - 他のカスタムエージェントの呼び出し
- `web` - URL コンテンツの取得、Web 検索
- `todo` - 構造化されたタスクリスト管理

**MCP Server ツールの指定**:
```yaml
tools: ["read", "edit", "github/list-repos"]  # 特定のツール
tools: ["playwright/*"]  # サーバーのすべてのツール
```

### model

タスクの複雑さに基づいてモデルを選択する。

```yaml
model: Claude Sonnet 4  # 複雑な分析と実装
model: Claude Haiku     # 簡単なフォーマット変更
```

**理由**: コスト最適化とレスポンス速度の向上

### target

実行環境を制限する。

```yaml
target: vscode           # VS Code のみ
target: github-copilot   # GitHub Copilot のみ
```

### infer

自動エージェント選択を制御する。

```yaml
infer: false  # 手動選択が必要な場合
# デフォルトは true
```

### handoffs - エージェント間の遷移設計

連続したワークフローを定義する。

```yaml
handoffs:
  - label: プランをレビュー
    agent: reviewer
    prompt: この実装計画をレビューして、改善提案を提供してください。
    send: false
```

**send プロパティの使い方**:
- `send: false` - ユーザーがプロンプトを確認・編集する (推奨)
- `send: true` - プロンプトを自動送信する (確実な次ステップの場合のみ)

### argument-hint

チャット入力フィールドに表示されるヒントテキストを提供する。

```yaml
argument-hint: "機能名または説明を入力してください"
```

## エージェント本文 (プロンプト) の設計

### 役割と責任の明確化

エージェントの役割を一文で定義し、責任範囲を明確に記述する。

```markdown
# プランニング専門家

技術計画の専門家として、包括的な実装計画の作成に集中する。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャをドキュメント化する
- 明確な手順、依存関係、タイムラインを含む計画を生成する

## 制約事項

- コードを実装しない。徹底的なドキュメント作成に集中する
- 明確な見出し、タスク分解、受け入れ基準を含む構造化された計画を作成する
```

### タスク固有の指示

具体的で実行可能な手順をリスト形式で提供する。

```markdown
## コードレビュープロセス

1. **セキュリティ**: SQL インジェクション、XSS、認証の問題をチェックする
2. **パフォーマンス**: 非効率なアルゴリズムと不要なループを特定する
3. **コード品質**: コーディング規約、命名規則、コメントを確認する
4. **テストカバレッジ**: 変更がテストでカバーされているかを評価する
```

### 他のファイルへの参照

重複を避けるため、他のファイルを Markdown リンクで参照する。

```markdown
詳細なコーディング規約については、プロジェクトのコーディング規約を参照してください。
```

### ツール参照記法

`#tool:<tool-name>` 構文を使用してツールを参照する。

```markdown
コードベースを探索するには #tool:search を使用してください。
```

## セキュリティのベストプラクティス

### シークレット管理

ファイル内にシークレットを平文で含めてはならない。

```yaml
# 推奨
env:
  API_KEY: ${{ secrets.API_KEY }}

# 非推奨
env:
  API_KEY: "my-secret-key"
```

**理由**: シークレット漏洩のリスクを防ぐ

組織レベルのエージェントの場合、リポジトリの「copilot」環境に設定し、`${{ secrets.SECRET_NAME }}` 構文を使用する。

### ツールアクセス制限

必要最小限のツールのみを付与し、特に `execute` ツールには注意する。

```yaml
# セキュリティレビューエージェント
tools: ["read", "search"]  # execute は不要である
```

### 環境分離

`target` プロパティを使用して実行環境を制限する。

```yaml
target: vscode  # VS Code でのみ使用する
```

## 一般的なアンチパターンと解決策

### ❌ ツール権限が広すぎる

```yaml
# 非推奨
tools: ["*"]
```

**解決策**: タスクに必要な最小限のツールのみを付与する

```yaml
# 推奨
tools: ["read", "search"]  # 分析タスクの場合
```

### ❌ 不明確な指示

```markdown
# 非推奨
コードを改善してください。
```

**解決策**: 具体的で実行可能な指示を与える

```markdown
# 推奨
1. 冗長なコードを削除する
2. 複雑な関数を小さく分割する
3. 適切なエラー処理を追加する
```

### ❌ すべてのタスクで同じモデルを使用する

**解決策**: タスクの複雑さに基づいてモデルを選択する

```yaml
model: Claude Sonnet 4  # 複雑な分析
model: Claude Haiku     # 簡単なフォーマット変更
```

## パフォーマンス最適化

### 効率的なツール選択

不要なツールを含めない (処理速度の低下を引き起こす)。

### プロンプトサイズ管理

プロンプトは最大 30,000 文字である。大きなファイルには参照リンクを使用する。

### モデル選択の最適化

軽量タスクには軽量モデル (Haiku) を使用し、複雑なタスクには高性能モデル (Sonnet) のみを使用する。

## 保守性とスケーラビリティ

### モジュール化

再利用可能な指示を別ファイルに分離し、Markdown リンクで参照する。

### バージョン管理

エージェントファイルを Git で管理し、変更履歴を追跡する。

### 統一された命名規則

エージェント名は目的を明確に反映し、ファイル名は kebab-case を使用する (例: `test-specialist.agent.md`)。

## 組織レベルのベストプラクティス

### Organization/Enterprise レベルのエージェント

`.github-private` リポジトリの `agents/` ディレクトリに配置する。MCP サーバー構成を含めることができる。

```yaml
---
name: org-security-reviewer
description: 組織のセキュリティ基準に基づくレビューエージェント
tools: ['read', 'search', 'security-scanner/*']
mcp-servers:
  security-scanner:
    type: 'local'
    command: 'security-tool'
    args: ['--config', 'org-config.json']
    tools: ["*"]
    env:
      API_KEY: ${{ secrets.SECURITY_API_KEY }}
---
```

### MCP Server の設定

**環境変数とシークレット参照の構文**:
- `${{ secrets.SECRET_NAME }}` - シークレット参照
- `${{ var.VARIABLE_NAME }}` - 環境変数参照

## 実用例

### 例 1: テスト専門家エージェント

```markdown
---
name: test-specialist
description: プロダクションコードを変更せずにテストカバレッジを向上させるテスト専門家
tools: ["read", "edit", "search", "execute"]
handoffs:
  - label: コードレビューを依頼
    agent: code-reviewer
    prompt: 作成したテストコードをレビューしてください。
    send: false
---

# テスト専門家

包括的なテストを通じてコード品質を向上させる。

## 責任範囲

- 既存のテストを分析し、カバレッジのギャップを特定する
- ベストプラクティスに従ってテストを作成する
- テストが独立的で、決定論的で、よくドキュメント化されていることを確認する
- 特に要求されない限り、プロダクションコードを変更しない

## 実行ガイドライン

- 明確なテスト説明を提供する
- 言語とフレームワークに適したテストパターンを使用する
- 可読性と保守性を優先する
```

### 例 2: 実装計画エージェント

```markdown
---
name: implementation-planner
description: 詳細な実装計画と技術仕様を Markdown 形式で作成する
tools: ["read", "search", "fetch"]
model: Claude Sonnet 4
handoffs:
  - label: 実装を開始
    agent: agent
    prompt: 上記の計画を実装してください。
    send: false
---

# 実装計画専門家

包括的な実装計画の作成に集中する。

## 責任範囲

- 要件を分析し、実行可能なタスクに分解する
- 詳細な技術仕様とアーキテクチャをドキュメント化する
- 明確な手順、依存関係、タイムラインを含む計画を生成する

## 実行ガイドライン

- 明確な見出し、タスク分解、受け入れ基準を含む構造化された計画を作成する
- テスト、デプロイ、潜在的なリスクの考慮事項を含める
- コード実装ではなく、徹底的なドキュメント作成に集中する
```

### 例 3: コードレビューエージェント

```markdown
---
name: code-reviewer
description: セキュリティ、パフォーマンス、品質の観点からコードをレビューする
tools: ["read", "search"]
---

# コードレビュー専門家

セキュリティ、パフォーマンス、コード品質の観点から徹底的なコードレビューを実施する。

## レビュープロセス

1. **セキュリティ**: SQL インジェクション、XSS、CSRF、認証機構をチェックする
2. **パフォーマンス**: 非効率なアルゴリズムと不要なループを特定する
3. **コード品質**: コーディング規約、命名規則、コメントを確認する
4. **テストカバレッジ**: 変更がテストでカバーされていることを確認する

## 出力形式

- **重大な問題**: セキュリティリスクとバグ
- **改善提案**: パフォーマンスとコード品質の向上
- **軽微なコメント**: スタイルと命名の改善
- **ポジティブな側面**: 称賛に値する実装の詳細
```

## まとめ: 重要な原則

1. **明確な役割定義** - エージェントの目的と責任を一文で説明する
2. **最小権限の原則** - 必要最小限のツールのみを付与する
3. **具体的な指示** - 実行可能で明確な指示を提供する
4. **Handoffs の活用** - エージェント間のスムーズな遷移を設計する
5. **セキュリティ** - シークレット管理とツールアクセス制限を徹底する
6. **モジュール化** - 再利用可能な指示を分離して保守性を向上させる
7. **適切なモデル選択** - タスクの複雑さに基づいてモデルを選択する

````
